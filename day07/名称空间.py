# 命名空间；名称空间

# 在python解释器开始执行之后, 就会在内存中开辟一个空间, 每当遇到一个变量的时候, 就把变量名和值之间的关系记录下来, 但是当遇到函数定义的时候, 解释器只是把函数名读入内存, 表示这个函数存在了,
# 至于函数内部的变量和逻辑, 解释器是不关心的. 也就是说一开始的时候函数只是加载进来, 仅此而已, 只有当函数被调用和访问的时候, 解释器才会根据函数内部声明的变量来进行开辟变量的内部空间. 随着函数执行完毕,
# 这些函数内部变量占用的空间也会随着函数执行完毕而被清空.
# 我们首先回忆一下Python代码运行的时候遇到函数是怎么做的，从Python
# 解释器开始执行之后，就在内存中开辟里一个空间，每当遇到一个变量的时候，就把变量名和值之间对应的关系记录下来，但是当遇到函数定义的时候，解释器只是象征性的将函数名读如内存，表示知道这个函数存在了，至于函数内部的变量和逻辑，解释器根本不关心。
#
# ​ 等执行到函数调用的时候，Python
# 解释器会再开辟一块内存来储存这个函数里面的内容，这个时候，才关注函数里面有哪些变量，而函数中的变量回储存在新开辟出来的内存中，函数中的变量只能在函数内部使用，并且会随着函数执行完毕，这块内存中的所有内容也会被清空。
#
# 我们给这个‘存放名字与值的关系’的空间起了一个名字-------命名空间。
#
# 代码在运行伊始，创建的存储“变量名与值的关系”的空间叫做全局命名空间；
#
# 在函数的运行中开辟的临时的空间叫做局部命名空间也叫做临时名称空间。

# 其实就是 全局变量和局部变量的关系。
# 全局名称空间:存在与整个py文件这个空间里。
# 局部名称空间（临时名称空间）:随着函数的结束而消失！可以用全局变量。
# a = 1
# b = 2
# def func():
#     a =11
#     b = 12
#     f = 5
#     print(a,b,f)
# c = 3
# func()
# print(a,b,c)
# 内置名称空间：python源码给你提供的一些内置函数，priint, input
# python 分为三个空间：
#   内置名称空间
#   全局名称空间（整个py文件）
#   局部名称空间（函数，函数执行时才开辟）
# 加载顺序：内置名称空间，全局名称空间，局部名称空间。

# 取值顺序（就近原则，LEGB原则）,单向不可逆。
# name = 'python'
# def func():
#     name='alex'
#     print(name)
# func()
# 作用域：
"""
两个作用域：
    全局作用域：内置名称空间。
    局部作用域：局部名称空间。
    局部可以引用全局变量，全局不可以用局部。
"""
# date = '周五'
# def func():
#     a = 5
#     print(date)
# func()
# # print(a) 错误
# count = 1
# def func():
#     # count += 2  错误 解释器人为你已经定义了局部变量count但是你没有定义count局部变量所以报错。
#     print(count)
# func()
# 局部作用域不能改编全局作用域变量，当python解释器读取到局部作用域时，发现了你对一个
# 局部变量进行修改的操作，解释器会人为你在局部已经定义过这个局部变量了，他就从局部找这个局部变量，报错了。
# 使用可以，不能改变。
def func():
    count = 1
    def inner():
        print(count)
    inner()
func()